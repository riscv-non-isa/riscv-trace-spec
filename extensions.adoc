[[sec:ext-mmacas]]
== Data Trace of Multiple-Memory Access and Compare and Swap v0.5 extension to Efficient Trace for RISC-V v2.0
The RISC-V Hart to Trace Interface (RHTI) specification is based on chapter 4 of the Efficient Trace for RISC-V v2.0 specification.
It adds *dtype* encodings to support data trace of multi-memory access instructions as defined by the Zcmp and Vector extensions, as well as Compare and Swap as defined by the Zacas extension.  This information also needs to be included in _te_data_ packets generated by the Trace Encoder, but there are no available unused encodings in the existing packets defined by the Efficient Trace for RISC-V v2.0 specification.  This extension defines revised packet formats that address this.

=== Revised packet formats
The following packet definitions replace those defined in <<dataTracePackets>>.  The *format* and *subtype* fields have been restructured but all other fields are the same.

[[sec:dtrace-format]]
==== format field

Data trace packets are classified by the *format* field.
This field is a maximum of 2 bits wide, but may be omitted completely if only unified loads and stores are supported, or reduced to 1 bit if unified multi-memory access load and stores are also supported.  2 bits are only required when tracing of atomics or CSRs is required, or if loads are split.

.Packet format for Unified load or store, with address and data
[%autowidth,align="center",float="center",cols="<,<,<",options="header"]
|===
| *Field name* | *Bits* | *Description*
|*format* | 0, 1 or 2 | Transaction class: +
00: Load or store +
01: Multi-memory access load or store +
(other codes select other packet formats)
|*subformat* | 2 | Transaction type: +
00: Unified load address, aligned +
01: Unified load address, unaligned +
10: Store, aligned address +
11: Store, unaligned address +
|*size* | max(1, clog2(clog2( _data_width_p_/8 + 1))) | Transfer size is
2^*size*^ bytes
|*diff* | 2 | 00: Full address and data (sync) +
01: Differential address, XOR-compressed data +
10: Differential address, full data +
11: Differentail address, differential data
|*data_len* | *size* | Number of bytes of data is *data_len* + 1
|*data* | 8 * (*data_len* + 1) | Data
|*address* | _daddress_width_p_ | Byte address if format is unaligned,
otherwise shift left by *size* to recover byte address
|===

.Packet format for Unified load or store, with address only
[%autowidth,align="center",float="center",cols="<,<,<",options="header"]
|===
| *Field name* | *Bits* | *Description*
|*format* | 0, 1 or 2 | Transaction class: +
00: Load or store +
01: Multi-memory access load or store +
(other codes select other packet formats)
|*subformat* | 2 | Transaction type: +
00: Unified load address, aligned +
01: Unified load address, unaligned +
10: Store, aligned address +
11: Store, unaligned address +
|*size* | max(1, clog2(clog2( _data_width_p_/8 + 1))) | Transfer size is
2^*size*^ bytes
|*diff* | 1 | 0: Full address (sync) +
1: Differential address
|*address* | _daddress_width_p_ | Byte address if format is unaligned,
otherwise shift left by *size* to recover byte address
|===

[[tab:te_datadx0y2]]
.Packet format for Unified load or store, with data only
[%autowidth,align="center",float="center",cols="<,<,<",options="header"]
|===
| *Field name* | *Bits* | *Description*
|*format* | 0, 1 or 2 | Transaction class: +
00: Load or store
01: Multi-memory access load or store
(other codes select other packet formats)
|*subformat* | 2 | Transaction type: +
00: Unified load address, aligned +
01: Unified load address, unaligned +
10: Store, aligned address +
11: Store, unaligned address +
|*size* | max(1, clog2(clog2( _data_width_p_/8 + 1))) | Transfer size is
2^*size*^ bytes
|*diff* | 1 or 2 | 00: Full data (sync) +
01: Compressed data (XOR if 2 bits) +
10: reserved +
11 : Differential data
|*data* | _data_width_p_ | Data
|===

.Packet format for Split load - Address only
[%autowidth,align="center",float="center",cols="<,<,<",options="header"]
|===
| *Field name* | *Bits* | *Description*
|*format* | 2 | Transaction class: +
00: Load or store
01: Multi-memory access load or store
(other codes select other packet formats)
|*subformat* | 2 | Transaction type: +
00: Split load address, aligned +
01: Split load address, unaligned +
|*size* | max(1, clog2(clog2( _data_width_p_/8 + 1))) | Transfer size is
2^*size*^ bytes
|*lrid* | _lrid_width_p_ | Load request ID
|*diff* | 1 | 0: Full address (sync) +
1: Differential address
|*address* | _daddress_width_p_ | Byte address if format is unaligned,
otherwise shift left by *size* to recover byte address
|===

.Packet format for Split load or atomic - Data only
[%autowidth,align="center",float="center",cols="<,<,<",options="header"]
|===
| *Field name* | *Bits* | *Description*
|*format* | 2 | Transaction type +
11: split load data +
(other codes select other packet formats)
|*size* | max(1, clog2(clog2( _data_width_p_/8 + 1))) | Transfer size is
2^*size*^ bytes
|*lrid* | _lrid_width_p_ | Load request ID
|*resp* | 2 | 00: Error (no data) +
01: XOR-compressed data +
10: Full data +
11: Differential data
|*data* | _data_width_p_ | Data
|===

.Packet format for Unified atomic with address and data
[%autowidth,align="center",float="center",cols="<,<,<",options="header"]
|===
| *Field name* | *Bits* | *Description*
|*format* | 2 | Transaction class: +
10: Atomic or CSR
(other codes select other packet formats)
|*subformat* | 3 | Atomic sub-type +
1000: Swap +
1001: ADD +
1010: AND +
1011: OR +
1100: XOR +
1101: MAX +
1110: MIN +
(other codes select other packet formats)
|*size* | max(1, clog2(clog2( _data_width_p_/8 + 1))) | Transfer size is
2^*size*^ bytes
|*diff* | 2 | 00: Full address and data (sync) +
01: Differential address, XOR-compressed data/operand +
10: Differential address, full data/operand +
11: Differential address, differential data/operand
|*op_len* | *size* | Number of bytes of operand is *op_len* + 1
|*operand* | 8 * (*op_len* + 1) | Operand. Value from rs2 before operator
applied
|*data_len* | *size* | Number of bytes of data is *data_len* + 1
|*data* | 8 * (*data_len* + 1) | Data
|*address* | _daddress_width_p_ | Address, aligned and encoded as per
size
|===

.Packet format for Unified CAS failure
[%autowidth,align="center",float="center",cols="<,<,<",options="header"]
|===
| *Field name* | *Bits* | *Description*
|*format* | 2 | Transaction class: +
10: Atomic or CSR
(other codes select other packet formats)
|*subformat* | 3 | Atomic sub-type +
0111: Compare and Swap failure+
(other codes select other packet formats)
|*size* | max(1, clog2(clog2( _data_width_p_/8 + 1))) | Transfer size is
2^*size*^ bytes
|*diff* | 2 | 00: Full address and data (sync) +
01: Differential address, XOR-compressed data/operand +
10: Differential address, full data/operand +
11: Differential address, differential data/operand
|*op_len* | *size* | Number of bytes of operand is *op_len* + 1
|*operand* | 8 * (*op_len* + 1) | Operand. Value from rs2 before operator applied
|*address* | _daddress_width_p_ | Address, aligned and encoded as per
size
|===

.Packet format for Unified atomic with address only
[%autowidth,align="center",float="center",cols="<,<,<",options="header"]
|===
| *Field name* | *Bits* | *Description*
|*format* | 2 | Transaction class: +
10: Atomic or CSR
(other codes select other packet formats)
|*subformat* | 3 | Atomic sub-type +
0111: compare and swap failure +
1000: Swap +
1001: ADD +
1010: AND +
1011: OR +
1100: XOR +
1101: MAX +
1110: MIN +
1111: conditional store failure +
(other codes select other packet formats)
|*size* | max(1, clog2(clog2( _data_width_p_/8 + 1))) | Transfer size is
2^*size*^ bytes
|*diff* | 1 | 0: Full address +
1: Differential address
|*address* | _daddress_width_p_ | Address, aligned and encoded as per
size
|===

.Packet format for Unified atomic with data only
[%autowidth,align="center",float="center",cols="<,<,<",options="header"]
|===
| *Field name* | *Bits* | *Description*
|*format* | 2 | Transaction class: +
10: Atomic or CSR
(other codes select other packet formats)
|*subformat* | 3 | Atomic sub-type +
1000: Swap +
1001: ADD +
1010: AND +
1011: OR +
1100: XOR +
1101: MAX +
1110: MIN +
(other codes select other packet formats)
|*size* | max(1, clog2(clog2( _data_width_p_/8 + 1))) | Transfer size is
2^*size*^ bytes
|*diff* | 1 or 2 | 00: Full data (sync) +
01: Compressed data/operand (XOR if 2 bits) +
10: reserved +
11: Differential data/operand
|*op_len* | *size* | Number of bytes of operand is *op_len* + 1
|*operand* | 8 * (*op_len* + 1) | Operand. Value from rs2 before operator
applied
|*data* | _data_width_p_ | Data
|===

.Packet format for Split atomic with operand and address only
[%autowidth,align="center",float="center",cols="<,<,<",options="header"]
|===
| *Field name* | *Bits* | *Description*
|*format* | 2 | Transaction class: +
10: Atomic or CSR
(other codes select other packet formats)
|*subformat* | 3 | Atomic sub-type +
1000: Swap +
1001: ADD +
1010: AND +
1011: OR +
1100: XOR +
1101: MAX +
1110: MIN +
(other codes select other packet formats)
|*size* | max(1, clog2(clog2( _data_width_p_/8 + 1))) | Transfer size is
2^*size*^ bytes
|*lrid* | _lrid_width_p_ | Load request ID
|*diff* | 1 or 2 | 00: Full address and operand (sync) +
01: Differential address, XOR-compressed operand +
10: Differential address, full operand +
11: Differential address, differential operand
|*op_len* | *size* | Number of bytes of operand is *op_len* + 1
|*operand* | 8 * (*op_len* + 1) | Operand. Value from rs2 before operator
applied
|*address* | _daddress_width_p_ |Address, aligned and encoded as per
size
|===

.Packet format for Unified CSR, with address, data and operand
[%autowidth,align="center",float="center",cols="<,<,<",options="header"]
|===
| *Field name* | *Bits* | *Description*
|*format* | 2 | Transaction class: +
10: Atomic or CSR
(other codes select other packet formats)
|*subformat* | 4 | CSR sub-type +
0100: RW +
0101: RS +
0110: RC +
(other codes select other packet formats)
|*diff* | 1 or 2 | 00: Full data/operand (sync) +
01: Compressed data/operand (XOR if 2 bits) +
10: reserved +
11 : Differential data/operand
|*data_len* | 2 or 3 | Number of bytes of data is *data_len* + 1
|*data* | 8 * (*data_len* 1) | Data
|*addr_msbs* | 6 | Address[11:6]
|*op_len* | 2 or 3 | Number of bytes of operand is *op_len* + 1
|*operand* | 8 * (*op_len* + 1) | Operand. Value from rs1 before operator
applied
|*addr_lsbs* | 6 | Address[5:0]
|===

.Packet format for Unified CSR, with address and read-only data (as determined by addr[11:10] = 11)
[%autowidth,align="center",float="center",cols="<,<,<",options="header"]
|===
| *Field name* | *Bits* | *Description*
|*format* | 2 | Transaction class: +
10: Atomic or CSR
(other codes select other packet formats)
|*subformat* | 4 | CSR sub-type +
0100: RW +
0101: RS +
0110: RC +
(other codes select other packet formats)
|*diff* | 1 or 2 | 00: Full data (sync) +
01: Compressed data/operand (XOR if 2 bits) +
10: reserved +
11 : Differential data/operand
|*data_len* | 2 or 3 | Number of bytes of data is *data_len* + 1
|*data* | 8 * (*data_len* + 1) | Data
|*addr_msbs* | 6 | Address[11:6]
|*addr_lsbs* | 6 | Address[5:0]
|===

.Packet format for Unified CSR, with address only
[%autowidth,align="center",float="center",cols="<,<,<",options="header"]
|===
| *Field name* | *Bits* | *Description*
|*format* | 2 | Transaction class: +
10: Atomic or CSR
(other codes select other packet formats)
|*subformat* | 4 | CSR sub-type +
0100: RW +
0101: RS +
0110: RC +
(other codes select other packet formats)
11: reserved
|*diff* | 0 or 1 | 0: Full address +
1: Differential address
|*addr_msbs* | 6 | Address[11:6]
|*addr_lsbs* | 6 | Address[5:0]
|===
