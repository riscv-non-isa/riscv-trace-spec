\chapter{Future directions} \label{Future}

The current focus is the compressed branch trace, however there a
number of other types of processor trace that would be useful 
(detailed below in no particular order). These
should be considered as possible features that maybe added in future,
once the current scope has been completed.

\section{Data trace}

The trace encoder will outputs packets to communicate information
about loads and stores to an off-chip decoder.  To reduce the amount
of bandwidth required, reporting data values will be optional, and
both address and data will be able to be encoded differentially when
it is beneficial to do so.  This entails outputting the difference
between the new value and the previous value of the same transfer
size, irrespective of transfer direction.

Unencoded values will be used for synchronisation and at other times.

\section{Fast profiling}

In this mode the encoder will provide a non-intrusive alternative to
the traditional method of profiling, which requires the processor to
be halted periodically so that the program counter can be sampled.
The encoder will issue packets when an exception, call or return is
detected, to report the next instruction executed (i.e. the
destination instruction).  Optionally, the encoder will also be able to
report the current instruction (i.e. the source instruction).

\section{Don't report the addresses of function returns}

In well behaved programs, the return from a function adjusts the PC back to the 
instruction immediately following the original function call.  As long as the 
encoder was enabled when the function call occurred (i.e. the call was traced),
the decoding software will be able to infer the return address of the function.
As function returns are usually performed using indirect jumps (e.g. \textit{jalr})
they would normally be treated as uninferable.  This run-time optional mode would
treat them as inferable, and would typically result in a significant increase in
trace efficiency.

\section{Don't report the addresses of exceptions}

The exception handler base address is specified by \textbf{\textit{stvec/mtvec}}, and 
optionally the lower address bits can be specified by (\textbf{\textit{mcause/scause}}.
As the latter is reported by the trace encoder when an exception occurs, the target
of the exception handler does not need to be reported explicitly, and an option to 
eliminate this would improve efficiency.

\section{Inter-instruction cycle counts}

In this mode the encoder will trace where the CPU is stalling by
reporting the number of cycles between successive instruction
retirements.

\section{Using branch prediction to further improve efficiency}

Rather than outputting branch maps detailing the taken/not taken state of every branch,
the encoder could include a branch predictor.  This would allow the encoder to 
report "N branches executed that matched the prediction", which would be a lot more
efficient in some circumstances, for example tight loops.  The decoder would need to 
model the same branch prediction algorithm in software.

\section{Using a jump target cache to further improve efficiency}

The encoder could include a small cache of uninferable jump targets, managed using a
least-recently-used (LRU) algorithm.  When an uninferable PC discontinuity occurs, if 
the target address is present in the cache, report the index number of the cache
entry (typically just a few bits) rather than the target address itself.  The decoder 
would need to model the cache in order to know the target address associated with
each cache entry.

